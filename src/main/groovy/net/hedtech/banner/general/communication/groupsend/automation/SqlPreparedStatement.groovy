/*******************************************************************************

 ï¿½ 2007 SunGard Higher Education.  All Rights Reserved.

 CONFIDENTIAL BUSINESS INFORMATION

 THIS PROGRAM IS PROPRIETARY INFORMATION OF SUNGARD HIGHER EDUCATIION AND IS NOT
 TO BE COPIED, REPRODUCED, LENT, OR DISPOSED OF, NOR USED FOR ANY PURPOSE OTHER 
 THAN THAT WHICH IT IS SPECIFICALLY PROVIDED WITHOUT THE WRITTEN PERMISSION OF 
 THE SAID COMPANY
 *******************************************************************************/
package net.hedtech.banner.general.communication.groupsend.automation;

//import oracle.jdbc.OraclePreparedStatement;
import java.sql.*

/**
 * Decorator for sql prepared statement; will be used to give more informative
 * toString in order to show values for prepared statement.  Used by legacy DAOs.
 * @author Shane Riddell
 */
public class SqlPreparedStatement implements PreparedStatement {

    //------------------------   variables  ------------------------------
    private final PreparedStatement statement;
    private final String sql;
    private final String[] parameters;
    
    //--------------------- Java 7 Specific methods ---------------------

    public void closeOnCompletion() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    public boolean isCloseOnCompletion() {
           throw new UnsupportedOperationException("Not supported yet.");
    } 

    //----------------------  public methods  ----------------------------


    public SqlPreparedStatement(Connection conn, String sql) throws SQLException {
        statement = conn.prepareStatement( sql );
        this.sql = sql;
        parameters = new String[countParameters( this.sql )];
    }


    @Override
    public String toString() {
        return fillValues( sql, parameters );
    }


    /**
     * Executes the SQL INSERT, UPDATE or DELETE statement
     * in this <code>PreparedStatement</code> object.
     * In addition,
     * SQL statements that return nothing, such as SQL DDL statements,
     * can be executed.
     *
     * @return either the row count for INSERT, UPDATE or DELETE statements;
     *         or 0 for SQL statements that return nothing
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int executeUpdate() throws SQLException {
        return statement.executeUpdate();
    }


    /**
     * Executes the SQL query in this <code>PreparedStatement</code> object
     * and returns the result set generated by the query.
     *
     * @return a ResultSet that contains the data produced by the
     *         query; never null
     * @throws java.sql.SQLException if a database access error occurs
     */
    public ResultSet executeQuery() throws SQLException {
        return statement.executeQuery();
    }


    /**
     * Sets the designated parameter to a Java double value.  The driver converts this
     * to an SQL DOUBLE value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setDouble( int parameterIndex, double x ) throws SQLException {
        statement.setDouble( parameterIndex, x );
        setParametersInArray( parameterIndex, new Double( x ) );
    }


    /**
     * Sets the designated parameter to a Java short value.  The driver converts this
     * to an SQL SMALLINT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setShort( int parameterIndex, short x ) throws SQLException {
        statement.setShort( parameterIndex, x );
        setParametersInArray( parameterIndex, new Short( x ) );
    }


    /**
     * Sets the designated parameter to SQL NULL.
     * <p/>
     * <P><B>Note:</B> You must specify the parameter's SQL type.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param sqlType        the SQL type code defined in java.sql.Types
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setNull( int parameterIndex, int sqlType ) throws SQLException {
        statement.setNull( parameterIndex, sqlType );
        setParametersInArray( parameterIndex, "NULL" );
    }


    /**
     * Sets the designated parameter to SQL NULL.
     * <p/>
     * <P><B>Note:</B> You must specify the parameter's SQL type.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param sqlType        the SQL type code defined in java.sql.Types
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setNull( int parameterIndex, int sqlType, String s ) throws SQLException {
        statement.setNull( parameterIndex, sqlType, s );
        setParametersInArray( parameterIndex, "NULL" );
    }


    /**
     * Sets the designated parameter to a Java boolean value.  The driver converts this
     * to an SQL BIT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setBoolean( int parameterIndex, boolean x ) throws SQLException {
        statement.setBoolean( parameterIndex, x );
        setParametersInArray( parameterIndex, new Boolean( x ) );
    }


    /**
     * Sets the designated parameter to a Java byte value.  The driver converts this
     * to an SQL TINYINT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setByte( int parameterIndex, byte x ) throws SQLException {
        statement.setByte( parameterIndex, x );
        setParametersInArray( parameterIndex, new Byte( x ) );

    }


    /**
     * Sets the designated parameter to a java.sql.Date value.  The driver converts this
     * to an SQL DATE value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setDate( int parameterIndex, java.sql.Date x ) throws SQLException {
        statement.setDate( parameterIndex, x );
        setParametersInArray( parameterIndex, x );
    }

    /**
     * Retrieves the number, types and properties of this
     * <code>PreparedStatement</code> object's parameters.
     *
     * @return a <code>ParameterMetaData</code> object that contains information
     *         about the number, types and properties of this
     *         <code>PreparedStatement</code> object's parameters
     * @throws java.sql.SQLException if a database access error occurs
     * @see java.sql.ParameterMetaData
     * @since 1.4
     */
    public ParameterMetaData getParameterMetaData() throws SQLException {
        return statement.getParameterMetaData();
    }

    public void setSQLXML( int parameterIndex, SQLXML xmlObject ) throws SQLException {
        statement.setSQLXML( parameterIndex, xmlObject );
    }


    /**
     * Sets the designated parameter to a java.sql.Date value.  The driver converts this
     * to an SQL DATE value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setDate( int parameterIndex, java.sql.Date x, java.util.Calendar cal ) throws SQLException {
        statement.setDate( parameterIndex, x, cal );
        setParametersInArray( parameterIndex, (x.toString() + "<<using format " + cal.toString() + ">>") );
    }


    /**
     * Sets the designated parameter to a Java int value.  The driver converts this
     * to an SQL INTEGER value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setInt( int parameterIndex, int x ) throws SQLException {
        statement.setInt( parameterIndex, x );
        setParametersInArray( parameterIndex, new Integer( x ) );
    }


    /**
     * Sets the designated parameter to a Java long value.  The driver converts this
     * to an SQL BIGINT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setLong( int parameterIndex, long x ) throws SQLException {
        statement.setLong( parameterIndex, x );
        setParametersInArray( parameterIndex, new Long( x ) );
    }


    /**
     * Sets the designated parameter to a Java float value.  The driver converts this
     * to an SQL FLOAT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setFloat( int parameterIndex, float x ) throws SQLException {
        statement.setFloat( parameterIndex, x );
        setParametersInArray( parameterIndex, new Float( x ) );
    }


    /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large UNICODE value is input to a LONGVARCHAR
     * parameter, it may be more practical to send it via a
     * java.io.InputStream. JDBC will read the data from the stream
     * as needed, until it reaches end-of-file.  The JDBC driver will
     * do any necessary conversion from UNICODE to the database char format.
     * The byte format of the Unicode stream must be Java UTF-8, as
     * defined in the Java Virtual Machine Specification.
     * <p/>
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the java input stream which contains the
     *                       UNICODE parameter value
     * @param length         the number of bytes in the stream
     * @throws java.sql.SQLException if a database access error occurs
     * @deprecated
     */
    @Deprecated
    public void setUnicodeStream( int parameterIndex, java.io.InputStream x, int length ) throws SQLException {
        statement.setUnicodeStream( parameterIndex, x, length );
        setParametersInArray( parameterIndex, "<<Set to values of the InputStream>>" );
    }


    /**
     * Sets the designated parameter to a java.lang.BigDecimal value.
     * The driver converts this to an SQL NUMERIC value when
     * it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setBigDecimal( int parameterIndex, BigDecimal x ) throws SQLException {
        statement.setBigDecimal( parameterIndex, x );
        setParametersInArray( parameterIndex, x );
    }

    /**
     * Sets the designated parameter to the given <code>java.net.URL</code> value.
     * The driver converts this to an SQL <code>DATALINK</code> value
     * when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the <code>java.net.URL</code> object to be set
     * @throws java.sql.SQLException if a database access error occurs
     * @since 1.4
     */
    public void setURL( int parameterIndex, URL x ) throws SQLException {
        statement.setURL( parameterIndex, x );
        setParametersInArray( parameterIndex, x );
    }


    /**
     * Sets the designated parameter to a Java String value.  The driver converts this
     * to an SQL VARCHAR or LONGVARCHAR value (depending on the argument's
     * size relative to the driver's limits on VARCHARs) when it sends
     * it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setString( int parameterIndex, String x ) throws SQLException {
        final int MAX_STRING_SIZE = 4000;
        if ((x != null) && (x.length() >= MAX_STRING_SIZE)) {
            throw new SQLException( "String size larger than max size of " + MAX_STRING_SIZE );
        }

        statement.setString( parameterIndex, x );
        setParametersInArray( parameterIndex, ("\"" + x + "\"") );
    }


    /**
     * Sets the designated parameter to a Java array of bytes.  The driver converts
     * this to an SQL VARBINARY or LONGVARBINARY (depending on the
     * argument's size relative to the driver's limits on VARBINARYs)
     * when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setBytes( int parameterIndex, byte[] x ) throws SQLException {
        statement.setBytes( parameterIndex, x );
        setParametersInArray( parameterIndex, "<< set to value of a passed byte[]>>" );
    }


    /**
     * Sets the value of the designated parameter with the given object.
     * This method is like setObject above, except that it assumes a scale of zero.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the object containing the input parameter value
     * @param targetSqlType  the SQL type (as defined in java.sql.Types) to be
     *                       sent to the database
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setObject( int parameterIndex, Object x, int targetSqlType ) throws SQLException {
        statement.setObject( parameterIndex, x, targetSqlType );
        setParametersInArray( parameterIndex, (x.toString() + " <<Using SQL Type: " + targetSqlType + ">>") );
    }


    /**
     * Sets the designated parameter to a java.sql.Time value.  The driver converts this
     * to an SQL TIME value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setTime( int parameterIndex, java.sql.Time x ) throws SQLException {
        statement.setTime( parameterIndex, x );
        setParametersInArray( parameterIndex, x );
    }


    /**
     * Sets the designated parameter to a java.sql.Time value.  The driver converts this
     * to an SQL TIME value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setTime( int parameterIndex, java.sql.Time x, java.util.Calendar cal ) throws SQLException {
        statement.setTime( parameterIndex, x, cal );
        setParametersInArray( parameterIndex, (x + "<<Using Format: " + cal.toString() + ">>") );
    }


    /**
     * Sets the designated parameter to a java.sql.Timestamp value.  The driver
     * converts this to an SQL TIMESTAMP value when it sends it to the
     * database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setTimestamp( int parameterIndex, java.sql.Timestamp x ) throws SQLException {
        statement.setTimestamp( parameterIndex, x );
        setParametersInArray( parameterIndex, x );
    }


    /**
     * Sets the designated parameter to a java.sql.Timestamp value.  The driver
     * converts this to an SQL TIMESTAMP value when it sends it to the
     * database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setTimestamp( int parameterIndex, java.sql.Timestamp x, java.util.Calendar cal ) throws SQLException {
        statement.setTimestamp( parameterIndex, x, cal );
        setParametersInArray( parameterIndex, (x + "<<Using Format: " + cal.toString() + ">>") );
    }


    /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large ASCII value is input to a LONGVARCHAR
     * parameter, it may be more practical to send it via a
     * java.io.InputStream. JDBC will read the data from the stream
     * as needed, until it reaches end-of-file.  The JDBC driver will
     * do any necessary conversion from ASCII to the database char format.
     * <p/>
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the Java input stream that contains the ASCII parameter value
     * @param length         the number of bytes in the stream
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setAsciiStream( int parameterIndex, java.io.InputStream x, int length ) throws SQLException {
        statement.setAsciiStream( parameterIndex, x, length );
        setParametersInArray( parameterIndex, "<<AsciiStream>>" );
    }


    /**
     * JDBC 2.0
     * <p/>
     * Sets the designated parameter to the given <code>Reader</code>
     * object, which is the given number of characters long.
     * When a very large UNICODE value is input to a LONGVARCHAR
     * parameter, it may be more practical to send it via a
     * java.io.Reader. JDBC will read the data from the stream
     * as needed, until it reaches end-of-file.  The JDBC driver will
     * do any necessary conversion from UNICODE to the database char format.
     * <p/>
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param reader         the java reader which contains the UNICODE data
     * @param length         the number of characters in the stream
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setCharacterStream( int parameterIndex, java.io.Reader reader, int length ) throws SQLException {
        statement.setCharacterStream( parameterIndex, reader, length );
        setParametersInArray( parameterIndex, "<<CharacterStream>>" );
    }


    /**
     * Sets the designated parameter to the given input stream, which will have
     * the specified number of bytes.
     * When a very large binary value is input to a LONGVARBINARY
     * parameter, it may be more practical to send it via a
     * java.io.InputStream. JDBC will read the data from the stream
     * as needed, until it reaches end-of-file.
     * <p/>
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the
     * standard interface.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the java input stream which contains the binary parameter value
     * @param length         the number of bytes in the stream
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setBinaryStream( int parameterIndex, java.io.InputStream x, int length ) throws SQLException {
        statement.setBinaryStream( parameterIndex, x, length );
        setParametersInArray( parameterIndex, "<<BinaryStream>>" );
    }


    /**
     * Clears the current parameter values immediately.
     * <P>In general, parameter values remain in force for repeated use of a
     * Statement. Setting a parameter value automatically clears its
     * previous value.  However, in some cases it is useful to immediately
     * release the resources used by the current parameter values; this can
     * be done by calling clearParameters.
     *
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void clearParameters() throws SQLException {
        statement.clearParameters();
    }


    /**
     * <p>Sets the value of a parameter using an object. The second
     * argument must be an object type; for integral values, the
     * java.lang equivalent objects should be used.
     * <p/>
     * <p>The given Java object will be converted to the targetSqlType
     * before being sent to the database.
     * <p/>
     * If the object has a custom mapping (is of a class implementing SQLData),
     * the JDBC driver should call its method <code>writeSQL</code> to write it
     * to the SQL data stream.
     * If, on the other hand, the object is of a class implementing
     * Ref, Blob, Clob, Struct,
     * or Array, the driver should pass it to the database as a value of the
     * corresponding SQL type.
     * <p/>
     * <p>Note that this method may be used to pass datatabase-
     * specific abstract data types.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the object containing the input parameter value
     * @param targetSqlType  the SQL type (as defined in java.sql.Types) to be
     *                       sent to the database. The scale argument may further qualify this type.
     * @param scale          for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
     *                       this is the number of digits after the decimal point.  For all other
     *                       types, this value will be ignored.
     * @throws java.sql.SQLException if a database access error occurs
     * @see java.sql.Types
     */
    public void setObject( int parameterIndex, Object x, int targetSqlType, int scale ) throws SQLException {
        statement.setObject( parameterIndex, x, targetSqlType, scale );
    }

    public void setBinaryStream( int parameterIndex, InputStream x ) throws SQLException {
        statement.setBinaryStream( parameterIndex, x  );
    }

    public void setRowId( int parameterIndex, RowId x ) throws SQLException {
        statement.setRowId( parameterIndex, x );
    }

    public void setNString( int parameterIndex, String value ) throws SQLException {
        statement.setNString( parameterIndex, value );
    }

    public void setNCharacterStream( int parameterIndex, Reader value, long length ) throws SQLException {
        statement.setNCharacterStream( parameterIndex, value, length );
    }

    public void setNClob( int parameterIndex, NClob value ) throws SQLException {
        statement.setNClob( parameterIndex, value );
    }

    public void setClob( int parameterIndex, Reader reader, long length ) throws SQLException {
        statement.setClob( parameterIndex, reader, length );
    }

    public void setBlob( int parameterIndex, InputStream inputStream, long length ) throws SQLException {
        statement.setBlob( parameterIndex, inputStream, length );
    }

    public void setNClob( int parameterIndex, Reader reader, long length ) throws SQLException {
        statement.setNClob( parameterIndex, reader, length );
    }

    public void setAsciiStream( int parameterIndex, InputStream x, long length ) throws SQLException {
        statement.setAsciiStream( parameterIndex, x, length );
    }

    public void setBinaryStream( int parameterIndex, InputStream x, long length ) throws SQLException {
        statement.setBinaryStream( parameterIndex, x, length );
    }

    public void setCharacterStream( int parameterIndex, Reader reader, long length ) throws SQLException {
        statement.setCharacterStream( parameterIndex, reader, length );
    }

    public void setAsciiStream( int parameterIndex, InputStream x ) throws SQLException {
        statement.setAsciiStream( parameterIndex, x );
    }

    public void setCharacterStream( int parameterIndex, Reader reader ) throws SQLException {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    public void setNCharacterStream( int parameterIndex, Reader value ) throws SQLException {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    public void setClob( int parameterIndex, Reader reader ) throws SQLException {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    public void setBlob( int parameterIndex, InputStream inputStream ) throws SQLException {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    public void setNClob( int parameterIndex, Reader reader ) throws SQLException {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    /**
     * JDBC 2.0
     * <p/>
     * Sets an Array parameter.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x an object representing an SQL array
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setArray( int i, Array x ) throws SQLException {
        statement.setArray( i, x );
        setParametersInArray( i, "<<Array>>" );
    }


    /**
     * <p>Sets the value of a parameter using an object; use the
     * java.lang equivalent objects for integral values.
     * <p/>
     * <p>The JDBC specification specifies a standard mapping from
     * Java Object types to SQL types.  The given argument java object
     * will be converted to the corresponding SQL type before being
     * sent to the database.
     * <p/>
     * <p>Note that this method may be used to pass datatabase-
     * specific abstract data types, by using a Driver-specific Java
     * type.
     * <p/>
     * If the object is of a class implementing SQLData,
     * the JDBC driver should call its method <code>writeSQL</code> to write it
     * to the SQL data stream.
     * If, on the other hand, the object is of a class implementing
     * Ref, Blob, Clob, Struct,
     * or Array, then the driver should pass it to the database as a value of the
     * corresponding SQL type.
     * <p/>
     * This method throws an exception if there is an ambiguity, for example, if the
     * object is of a class implementing more than one of those interfaces.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x              the object containing the input parameter value
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setObject( int parameterIndex, Object x ) throws SQLException {
        statement.setObject( parameterIndex, x );
        setParametersInArray( parameterIndex, x );
    }


    /**
     * Executes any kind of SQL statement.
     * Some prepared statements return multiple results; the execute
     * method handles these complex statements as well as the simpler
     * form of statements handled by executeQuery and executeUpdate.
     *
     * @throws java.sql.SQLException if a database access error occurs
     * @see java.sql.Statement#execute
     */
    public boolean execute() throws SQLException {
        return statement.execute();
    }


    /**
     * JDBC 2.0
     * <p/>
     * Adds a set of parameters to the batch.
     *
     * @throws java.sql.SQLException if a database access error occurs
     * @see java.sql.Statement#addBatch
     */
    public void addBatch() throws SQLException {
        statement.addBatch();
    }


    /**
     * JDBC 2.0
     * <p/>
     * Sets a REF(&lt;structured-type&gt;) parameter.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x an object representing data of an SQL REF Type
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setRef( int i, Ref x ) throws SQLException {
        statement.setRef( i, x );
        setParametersInArray( i, "<<REF Type>>" );
    }


    /**
     * JDBC 2.0
     * <p/>
     * Sets a BLOB parameter.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x an object representing a BLOB
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setBlob( int i, Blob x ) throws SQLException {
        statement.setBlob( i, x );
        setParametersInArray( i, "<<Blob>>" );
    }


    /**
     * JDBC 2.0
     * <p/>
     * Sets a CLOB parameter.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x an object representing a CLOB
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setClob( int i, Clob x ) throws SQLException {
        statement.setClob( i, x );
        setParametersInArray( i, "<<Clob>>" );
    }


    /**
     * JDBC 2.0
     * <p/>
     * Gets the number, types and properties of a ResultSet's columns.
     *
     * @return the description of a ResultSet's columns
     * @throws java.sql.SQLException if a database access error occurs
     */
    public ResultSetMetaData getMetaData() throws SQLException {
        return statement.getMetaData();
    }


    /**
     * Executes a SQL statement that returns a single ResultSet.
     *
     * @param sql typically this is a static SQL SELECT statement
     * @return a ResultSet that contains the data produced by the
     *         query; never null
     * @throws java.sql.SQLException if a database access error occurs
     */
    public ResultSet executeQuery( String sql ) throws SQLException {
        return statement.executeQuery( sql );
    }

    /**
     * Executes an SQL INSERT, UPDATE or DELETE statement. In addition,
     * SQL statements that return nothing, such as SQL DDL statements,
     * can be executed.
     *
     * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
     *            statement that returns nothing
     * @return either the row count for INSERT, UPDATE or DELETE or 0
     *         for SQL statements that return nothing
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int executeUpdate( String sql ) throws SQLException {
        return statement.executeUpdate( sql );
    }

    /**
     * Releases this <code>Statement</code> object's database
     * and JDBC resources immediately instead of waiting for
     * this to happen when it is automatically closed.
     * It is generally good practice to release resources as soon as
     * you are finished with them to avoid tying up database
     * resources.
     * <P><B>Note:</B> A Statement is automatically closed when it is
     * garbage collected. When a Statement is closed, its current
     * ResultSet, if one exists, is also closed.
     *
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void close() throws SQLException {
        statement.close();
    }

    //----------------------------------------------------------------------

    /**
     * Returns the maximum number of bytes allowed
     * for any column value.
     * This limit is the maximum number of bytes that can be
     * returned for any column value.
     * The limit applies only to BINARY,
     * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
     * columns.  If the limit is exceeded, the excess data is silently
     * discarded.
     *
     * @return the current max column size limit; zero means unlimited
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int getMaxFieldSize() throws SQLException {
        return statement.getMaxFieldSize();
    }

    /**
     * Sets the limit for the maximum number of bytes in a column to
     * the given number of bytes.  This is the maximum number of bytes
     * that can be returned for any column value.  This limit applies
     * only to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
     * LONGVARCHAR fields.  If the limit is exceeded, the excess data
     * is silently discarded. For maximum portability, use values
     * greater than 256.
     *
     * @param max the new max column size limit; zero means unlimited
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setMaxFieldSize( int max ) throws SQLException {
        statement.setMaxFieldSize( max );
    }

    /**
     * Retrieves the maximum number of rows that a
     * ResultSet can contain.  If the limit is exceeded, the excess
     * rows are silently dropped.
     *
     * @return the current max row limit; zero means unlimited
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int getMaxRows() throws SQLException {
        return statement.getMaxRows();
    }

    /**
     * Sets the limit for the maximum number of rows that any
     * ResultSet can contain to the given number.
     * If the limit is exceeded, the excess
     * rows are silently dropped.
     *
     * @param max the new max rows limit; zero means unlimited
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setMaxRows( int max ) throws SQLException {
        statement.setMaxRows( max );
    }

    /**
     * Sets escape processing on or off.
     * If escape scanning is on (the default), the driver will do
     * escape substitution before sending the SQL to the database.
     * <p/>
     * Note: Since prepared statements have usually been parsed prior
     * to making this call, disabling escape processing for prepared
     * statements will have no effect.
     *
     * @param enable true to enable; false to disable
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setEscapeProcessing( boolean enable ) throws SQLException {
        statement.setEscapeProcessing( enable );
    }

    /**
     * Retrieves the number of seconds the driver will
     * wait for a Statement to execute. If the limit is exceeded, a
     * SQLException is thrown.
     *
     * @return the current query timeout limit in seconds; zero means unlimited
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int getQueryTimeout() throws SQLException {
        return statement.getQueryTimeout();
    }

    /**
     * Sets the number of seconds the driver will
     * wait for a Statement to execute to the given number of seconds.
     * If the limit is exceeded, a SQLException is thrown.
     *
     * @param seconds the new query timeout limit in seconds; zero means
     *                unlimited
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setQueryTimeout( int seconds ) throws SQLException {
        statement.setQueryTimeout( seconds );
    }

    /**
     * Moves to this <code>Statement</code> object's next result, deals with
     * any current <code>ResultSet</code> object(s) according  to the instructions
     * specified by the given flag, and returns
     * <code>true</code> if the next result is a <code>ResultSet</code> object.
     * <p/>
     * <P>There are no more results when the following is true:
     * <PRE>
     * // stmt is a Statement object
     * ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1))
     * </PRE>
     *
     * @param current one of the following <code>Statement</code>
     *                constants indicating what should happen to current
     *                <code>ResultSet</code> objects obtained using the method
     *                <code>getResultSet</code>:
     *                <code>Statement.CLOSE_CURRENT_RESULT</code>,
     *                <code>Statement.KEEP_CURRENT_RESULT</code>, or
     *                <code>Statement.CLOSE_ALL_RESULTS</code>
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     *         object; <code>false</code> if it is an update count or there are no
     *         more results
     * @throws java.sql.SQLException if a database access error occurs or the argument
     *                               supplied is not one of the following:
     *                               <code>Statement.CLOSE_CURRENT_RESULT</code>,
     *                               <code>Statement.KEEP_CURRENT_RESULT</code>, or
     *                               <code>Statement.CLOSE_ALL_RESULTS</code>
     * @see #execute
     * @since 1.4
     */
    public boolean getMoreResults( int current ) throws SQLException {
        return statement.getMoreResults( current );
    }


    /**
     * Cancels this <code>Statement</code> object if both the DBMS and
     * driver support aborting an SQL statement.
     * This method can be used by one thread to cancel a statement that
     * is being executed by another thread.
     *
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void cancel() throws SQLException {
        statement.cancel();
    }

    /**
     * Retrieves the first warning reported by calls on this Statement.
     * Subsequent Statement warnings will be chained to this
     * SQLWarning.
     * <p/>
     * <p>The warning chain is automatically cleared each time
     * a statement is (re)executed.
     * <p/>
     * <P><B>Note:</B> If you are processing a ResultSet, any
     * warnings associated with ResultSet reads will be chained on the
     * ResultSet object.
     *
     * @return the first SQLWarning or null
     * @throws java.sql.SQLException if a database access error occurs
     */
    public SQLWarning getWarnings() throws SQLException {
        return statement.getWarnings();
    }

    /**
     * Executes the given SQL statement and signals the driver that the
     * auto-generated keys indicated in the given array should be made available
     * for retrieval.  The driver will ignore the array if the SQL statement
     * is not an <code>INSERT</code> statement.
     *
     * @param sql         an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *                    <code>DELETE</code> statement or an SQL statement that returns nothing
     * @param columnNames an array of the names of the columns that should be
     *                    returned from the inserted row
     * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>,
     *         or <code>DELETE</code> statements, or 0 for SQL statements
     *         that return nothing
     * @throws java.sql.SQLException if a database access error occurs, the SQL
     *                               statement returns a <code>ResultSet</code> object, or the
     *                               second argument supplied to this method is not a <code>String</code> array
     *                               whose elements are valid column names
     * @since 1.4
     */
    public int executeUpdate( String sql, String[] columnNames ) throws SQLException {
        return statement.executeUpdate( sql, columnNames );
    }

    /**
     * Executes the given SQL statement, which may return multiple results,
     * and signals the driver that the
     * auto-generated keys indicated in the given array should be made available
     * for retrieval. This array contains the names of the columns in the
     * target table that contain the auto-generated keys that should be made
     * available. The driver will ignore the array if the given SQL statement
     * is not an <code>INSERT</code> statement.
     * <p/>
     * In some (uncommon) situations, a single SQL statement may return
     * multiple result sets and/or update counts.  Normally you can ignore
     * this unless you are (1) executing a stored procedure that you know may
     * return multiple results or (2) you are dynamically executing an
     * unknown SQL string.
     * <p/>
     * The <code>execute</code> method executes an SQL statement and indicates the
     * form of the first result.  You must then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to
     * move to any subsequent result(s).
     *
     * @param sql         any SQL statement
     * @param columnNames an array of the names of the columns in the inserted
     *                    row that should be made available for retrieval by a call to the
     *                    method <code>getGeneratedKeys</code>
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     *         object; <code>false</code> if it is an update count or there
     *         are no more results
     * @throws java.sql.SQLException if a database access error occurs or the
     *                               elements of the <code>String</code> array passed to this
     *                               method are not valid column names
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     * @see #getGeneratedKeys
     * @since 1.4
     */
    public boolean execute( String sql, String[] columnNames ) throws SQLException {
        return statement.execute( sql, columnNames );
    }


    /**
     * Clears all the warnings reported on this <code>Statement</code>
     * object. After a call to this method,
     * the method <code>getWarnings</code> will return
     * null until a new warning is reported for this Statement.
     *
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void clearWarnings() throws SQLException {
        statement.clearWarnings();
    }

    /**
     * Defines the SQL cursor name that will be used by
     * subsequent Statement <code>execute</code> methods. This name can then be
     * used in SQL positioned update/delete statements to identify the
     * current row in the ResultSet generated by this statement.  If
     * the database doesn't support positioned update/delete, this
     * method is a noop.  To insure that a cursor has the proper isolation
     * level to support updates, the cursor's SELECT statement should be
     * of the form 'select for update ...'. If the 'for update' phrase is
     * omitted, positioned updates may fail.
     * <p/>
     * <P><B>Note:</B> By definition, positioned update/delete
     * execution must be done by a different Statement than the one
     * which generated the ResultSet being used for positioning. Also,
     * cursor names must be unique within a connection.
     *
     * @param name the new cursor name, which must be unique within
     *             a connection
     * @throws java.sql.SQLException if a database access error occurs
     */
    public void setCursorName( String name ) throws SQLException {
        statement.setCursorName( name );
    }

    //----------------------- Multiple Results --------------------------

    /**
     * Executes a SQL statement that may return multiple results.
     * Under some (uncommon) situations a single SQL statement may return
     * multiple result sets and/or update counts.  Normally you can ignore
     * this unless you are (1) executing a stored procedure that you know may
     * return multiple results or (2) you are dynamically executing an
     * unknown SQL string.  The  methods <code>execute</code>,
     * <code>getMoreResults</code>, <code>getResultSet</code>,
     * and <code>getUpdateCount</code> let you navigate through multiple results.
     * <p/>
     * The <code>execute</code> method executes a SQL statement and indicates the
     * form of the first result.  You can then use getResultSet or
     * getUpdateCount to retrieve the result, and getMoreResults to
     * move to any subsequent result(s).
     *
     * @param sql any SQL statement
     * @return true if the next result is a ResultSet; false if it is
     *         an update count or there are no more results
     * @throws java.sql.SQLException if a database access error occurs
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     */
    public boolean execute( String sql ) throws SQLException {
        return statement.execute( sql );
    }

    /**
     * Executes the given SQL statement and signals the driver with the
     * given flag about whether the
     * auto-generated keys produced by this <code>Statement</code> object
     * should be made available for retrieval.
     *
     * @param sql               must be an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *                          <code>DELETE</code> statement or an SQL statement that
     *                          returns nothing
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys
     *                          should be made available for retrieval;
     *                          one of the following constants:
     *                          <code>Statement.RETURN_GENERATED_KEYS</code>
     *                          <code>Statement.NO_GENERATED_KEYS</code>
     * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>
     *         or <code>DELETE</code> statements, or <code>0</code> for SQL
     *         statements that return nothing
     * @throws java.sql.SQLException if a database access error occurs, the given
     *                               SQL statement returns a <code>ResultSet</code> object, or
     *                               the given constant is not one of those allowed
     * @since 1.4
     */
    public int executeUpdate( String sql, int autoGeneratedKeys ) throws SQLException {
        return statement.executeUpdate( sql, autoGeneratedKeys );
    }

    /**
     * Executes the given SQL statement, which may return multiple results,
     * and signals the driver that any
     * auto-generated keys should be made available
     * for retrieval.  The driver will ignore this signal if the SQL statement
     * is not an <code>INSERT</code> statement.
     * <p/>
     * In some (uncommon) situations, a single SQL statement may return
     * multiple result sets and/or update counts.  Normally you can ignore
     * this unless you are (1) executing a stored procedure that you know may
     * return multiple results or (2) you are dynamically executing an
     * unknown SQL string.
     * <p/>
     * The <code>execute</code> method executes an SQL statement and indicates the
     * form of the first result.  You must then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to
     * move to any subsequent result(s).
     *
     * @param sql               any SQL statement
     * @param autoGeneratedKeys a constant indicating whether auto-generated
     *                          keys should be made available for retrieval using the method
     *                          <code>getGeneratedKeys</code>; one of the following constants:
     *                          <code>Statement.RETURN_GENERATED_KEYS</code> or
     *                          <code>Statement.NO_GENERATED_KEYS</code>
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     *         object; <code>false</code> if it is an update count or there are
     *         no results
     * @throws java.sql.SQLException if a database access error occurs or the second
     *                               parameter supplied to this method is not
     *                               <code>Statement.RETURN_GENERATED_KEYS</code> or
     *                               <code>Statement.NO_GENERATED_KEYS</code>.
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     * @see #getGeneratedKeys
     * @since 1.4
     */
    public boolean execute( String sql, int autoGeneratedKeys ) throws SQLException {
        return statement.execute( sql, autoGeneratedKeys );
    }

    /**
     * Executes the given SQL statement and signals the driver that the
     * auto-generated keys indicated in the given array should be made available
     * for retrieval.  The driver will ignore the array if the SQL statement
     * is not an <code>INSERT</code> statement.
     *
     * @param sql           an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *                      <code>DELETE</code> statement or an SQL statement that returns nothing,
     *                      such as an SQL DDL statement
     * @param columnIndexes an array of column indexes indicating the columns
     *                      that should be returned from the inserted row
     * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>,
     *         or <code>DELETE</code> statements, or 0 for SQL statements
     *         that return nothing
     * @throws java.sql.SQLException if a database access error occurs, the SQL
     *                               statement returns a <code>ResultSet</code> object, or the
     *                               second argument supplied to this method is not an <code>int</code> array
     *                               whose elements are valid column indexes
     * @since 1.4
     */
    public int executeUpdate( String sql, int[] columnIndexes ) throws SQLException {
        return statement.executeUpdate( sql, columnIndexes );
    }

    /**
     * Executes the given SQL statement, which may return multiple results,
     * and signals the driver that the
     * auto-generated keys indicated in the given array should be made available
     * for retrieval.  This array contains the indexes of the columns in the
     * target table that contain the auto-generated keys that should be made
     * available. The driver will ignore the array if the given SQL statement
     * is not an <code>INSERT</code> statement.
     * <p/>
     * Under some (uncommon) situations, a single SQL statement may return
     * multiple result sets and/or update counts.  Normally you can ignore
     * this unless you are (1) executing a stored procedure that you know may
     * return multiple results or (2) you are dynamically executing an
     * unknown SQL string.
     * <p/>
     * The <code>execute</code> method executes an SQL statement and indicates the
     * form of the first result.  You must then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to
     * move to any subsequent result(s).
     *
     * @param sql           any SQL statement
     * @param columnIndexes an array of the indexes of the columns in the
     *                      inserted row that should be  made available for retrieval by a
     *                      call to the method <code>getGeneratedKeys</code>
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     *         object; <code>false</code> if it is an update count or there
     *         are no results
     * @throws java.sql.SQLException if a database access error occurs or the
     *                               elements in the <code>int</code> array passed to this method
     *                               are not valid column indexes
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     * @since 1.4
     */
    public boolean execute( String sql, int[] columnIndexes ) throws SQLException {
        return statement.execute( sql, columnIndexes );
    }


    /**
     * Returns the current result as a <code>ResultSet</code> object.
     * This method should be called only once per result.
     *
     * @return the current result as a ResultSet; null if the result
     *         is an update count or there are no more results
     * @throws java.sql.SQLException if a database access error occurs
     * @see #execute
     */
    public ResultSet getResultSet() throws SQLException {
        return statement.getResultSet();
    }

    /**
     * Returns the current result as an update count;
     * if the result is a ResultSet or there are no more results, -1
     * is returned.
     * This method should be called only once per result.
     *
     * @return the current result as an update count; -1 if it is a
     *         ResultSet or there are no more results
     * @throws java.sql.SQLException if a database access error occurs
     * @see #execute
     */
    public int getUpdateCount() throws SQLException {
        return statement.getUpdateCount();
    }

    /**
     * Moves to a Statement's next result.  It returns true if
     * this result is a ResultSet.  This method also implicitly
     * closes any current ResultSet obtained with getResultSet.
     * <p/>
     * There are no more results when (!getMoreResults() &&
     * (getUpdateCount() == -1)
     *
     * @return true if the next result is a ResultSet; false if it is
     *         an update count or there are no more results
     * @throws java.sql.SQLException if a database access error occurs
     * @see #execute
     */
    public boolean getMoreResults() throws SQLException {
        return statement.getMoreResults();
    }

    //--------------------------JDBC 2.0-----------------------------


    /**
     * JDBC 2.0
     * <p/>
     * Gives the driver a hint as to the direction in which
     * the rows in a result set
     * will be processed. The hint applies only to result sets created
     * using this Statement object.  The default value is
     * ResultSet.FETCH_FORWARD.
     * <p>Note that this method sets the default fetch direction for
     * result sets generated by this <code>Statement</code> object.
     * Each result set has its own methods for getting and setting
     * its own fetch direction.
     *
     * @param direction the initial direction for processing rows
     * @throws java.sql.SQLException if a database access error occurs
     *                      or the given direction
     *                      is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
     *                      ResultSet.FETCH_UNKNOWN
     */
    public void setFetchDirection( int direction ) throws SQLException {
        statement.setFetchDirection( direction );
    }

    /**
     * JDBC 2.0
     * <p/>
     * Retrieves the direction for fetching rows from
     * database tables that is the default for result sets
     * generated from this <code>Statement</code> object.
     * If this <code>Statement</code> object has not set
     * a fetch direction by calling the method <code>setFetchDirection</code>,
     * the return value is implementation-specific.
     *
     * @return the default fetch direction for result sets generated
     *         from this <code>Statement</code> object
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int getFetchDirection() throws SQLException {
        return statement.getFetchDirection();
    }

    /**
     * JDBC 2.0
     * <p/>
     * Gives the JDBC driver a hint as to the number of rows that should
     * be fetched from the database when more rows are needed.  The number
     * of rows specified affects only result sets created using this
     * statement. If the value specified is zero, then the hint is ignored.
     * The default value is zero.
     *
     * @param rows the number of rows to fetch
     * @throws java.sql.SQLException if a database access error occurs, or the
     *                      condition 0 <= rows <= this.getMaxRows() is not satisfied.
     */
    public void setFetchSize( int rows ) throws SQLException {
        statement.setFetchSize( rows );
    }

    /**
     * JDBC 2.0
     * <p/>
     * Retrieves the number of result set rows that is the default
     * fetch size for result sets
     * generated from this <code>Statement</code> object.
     * If this <code>Statement</code> object has not set
     * a fetch size by calling the method <code>setFetchSize</code>,
     * the return value is implementation-specific.
     *
     * @return the default fetch size for result sets generated
     *         from this <code>Statement</code> object
     * @throws java.sql.SQLException if a database access error occurs
     */
    public int getFetchSize() throws SQLException {
        return statement.getFetchSize();
    }

    /**
     * JDBC 2.0
     * <p/>
     * Retrieves the result set concurrency.
     */
    public int getResultSetConcurrency() throws SQLException {
        return statement.getResultSetConcurrency();
    }

    /**
     * Retrieves the result set holdability for <code>ResultSet</code> objects
     * generated by this <code>Statement</code> object.
     *
     * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @throws java.sql.SQLException if a database access error occurs
     * @since 1.4
     */
    public int getResultSetHoldability() throws SQLException {
        return statement.getResultSetHoldability();
    }

    public boolean isClosed() throws SQLException {
        return statement.isClosed();
    }

    public void setPoolable( boolean poolable ) throws SQLException {
        statement.setPoolable( poolable );
    }

    public boolean isPoolable() throws SQLException {
        return statement.isPoolable();
    }


    /**
     * JDBC 2.0
     * <p/>
     * Determine the result set type.
     */
    public int getResultSetType() throws SQLException {
        return statement.getResultSetType();
    }

    /**
     * JDBC 2.0
     * <p/>
     * Adds a SQL command to the current batch of commmands for the statement.
     * This method is optional.
     *
     * @param sql typically this is a static SQL INSERT or UPDATE statement
     * @throws java.sql.SQLException if a database access error occurs, or the
     *                      driver does not support batch statements
     */
    public void addBatch( String sql ) throws SQLException {
        statement.addBatch( sql );
    }

    /**
     * JDBC 2.0
     * <p/>
     * Makes the set of commands in the current batch empty.
     * This method is optional.
     *
     * @throws java.sql.SQLException if a database access error occurs or the
     *                      driver does not support batch statements
     */
    public void clearBatch() throws SQLException {
        statement.clearBatch();
    }

    /**
     * JDBC 2.0
     * <p/>
     * Submits a batch of commands to the database for execution.
     * This method is optional.
     *
     * @return an array of update counts containing one element for each
     *         command in the batch.  The array is ordered according
     *         to the order in which commands were inserted into the batch.
     * @throws java.sql.SQLException if a database access error occurs or the
     *                      driver does not support batch statements
     */
    public int[] executeBatch() throws SQLException {
        return statement.executeBatch();
    }

    /**
     * JDBC 2.0
     * <p/>
     * Returns the <code>Connection</code> object
     * that produced this <code>Statement</code> object.
     *
     * @return the connection that produced this statement
     * @throws java.sql.SQLException if a database access error occurs
     */
    public Connection getConnection() throws SQLException {
        return statement.getConnection();
    }

    /**
     * Retrieves any auto-generated keys created as a result of executing this
     * <code>Statement</code> object. If this <code>Statement</code> object did
     * not generate any keys, an empty <code>ResultSet</code>
     * object is returned.
     *
     * @return a <code>ResultSet</code> object containing the auto-generated key(s)
     *         generated by the execution of this <code>Statement</code> object
     * @throws java.sql.SQLException if a database access error occurs
     * @since 1.4
     */
    public ResultSet getGeneratedKeys() throws SQLException {
        return statement.getGeneratedKeys();
    }


    /**
     * Uses Oracle specific functionality for setting large strings on Clobs.
     */
//    public void setStringForClob( int index, String s ) throws SQLException {
//        ((OraclePreparedStatement) statement).setStringForClob( index, s );
//    }

    //------------------------ private methods --------------------------------


    /**
     * Sets the passed object in the parameters array in the spot of the passed
     * index.
     *
     * @param index index of passed object in sql statement.
     * @param x     object to be stored in parameters array.
     */
    private void setParametersInArray( int index, Object x ) {
        parameters[--index] = String.valueOf(x);
    }


    /**
     * Counts the number of parameters that need to be set in the
     * passed sql statement.
     *
     * @param sql sql statement
     */
    private static int countParameters( String sql ) {
        int index = 0;
        int count = 0;

        while (true) {
            index = sql.indexOf( "?", index );
            if (index == -1) {
                break;
            } else {
                index++;
                count++;
            }
        }
        return count;
    }


    /**
     * Replaces the "?" in the sql statement with the appropriate parameters.
     *
     * @param sql        sql statement
     * @param parameters parameters to be inserted in place of the "?" in the passed
     *                   sql statemnet
     */
    private static String fillValues( String sql, String[] parameters ) {

        String withValues = "";
        int index = 0;
        int previousIndex = 0;
        int count = 0;
        boolean loop = true;

        while (loop) {

            index = sql.indexOf( "?", index );

            if (index != -1) {
                withValues = withValues + (sql.substring( previousIndex, index ));
                withValues = withValues + (parameters[count] == null ? "NULL" : parameters[count]);
                count++;
            } else {
                withValues = withValues + (sql.substring( previousIndex, sql.length() ));
                loop = false;
            }
            index++;
            previousIndex = index;
        }
        return withValues;

    }

    public <T> T unwrap( Class<T> iface ) throws SQLException {
        return statement.unwrap( iface );
    }

    public boolean isWrapperFor( Class<?> iface ) throws SQLException {
        return statement.isWrapperFor( iface );
    }
}
